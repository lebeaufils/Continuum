#ifndef PARTICLES_H_
#define PARTICLES_H_

#include "LevelSet.h"
#include <unordered_map> //to be replaced by perfect hash function if time permits

//------------------------------------------------------------
//Particles 
//------------------------------------------------------------
//Particles are represented by a levelset function
struct Particle //NEEDS WORK
{
	//RB_2D should store particles rather than levelsets.
	//each particle can have its reference levelset and nodes
	double density = 3000;

	LevelSet ls;
	vector2 centroid; //initial, fixed
	vector2 centre;
	double size; //size of AABB, length of box

	vector2 vc; //translational velocity
	double w; //angular velocity
	vector2 s; //total displacement
	double theta; //total rotation
	std::vector<vector2> nodes;
	std::vector<vector2> ref_nodes;
	//???If the mass of the Particle is nott important

	//Stiffness
	double damping_coefficient; //Dampens the oscillation to simulate dissipation of energy
	double miu; //interparticle friction coefficient
	double k_n; //normal contact stiffness
	double k_s; //shear contact stiffness
	//Forces
	vector2 force; //Linear force
	std::map <int, vector2> springs; //Tangential spring that accumulates strain for each collision
	double torque; //Accumuluator for torque

	bool in_collision; 

	Particle() : ls(), centroid(0, 0), centre(0, 0), size(0), vc(0, 0), w(0), s(0, 0), theta(0), nodes(0), ref_nodes(0), damping_coefficient(0.24), miu(0.26), k_n(1e5), k_s(1e5), force(0, 0), force_t(0, 0), torque(0), in_collision(false) {}
	Particle(const Domain2D&, const Coordinates&, double);
	Particle(const Polygon&, const Domain2D&);
	//Particle(const Particle&) //copy constructor
	Particle(const Particle& gr);
	~Particle() {};

	//void initialise(const Polygon&, const Domain2D&);
	//Particle(double d); //no real need to specify density for rigid bodies
	double diameter(); //estimated particle diameter, equidiv?;

	void set_velocity(const vector2&, double);
	LevelSet motion(const Domain2D&, const vector2&, double);

	//-----------------------------------------------------
	//Inertial properties
	//-----------------------------------------------------
	static double mass(const Particle&, const Domain2D&);
	static vector2 center_of_mass(const LevelSet&, const Particle&, const Domain2D&);
	static double moment_of_inertia(const LevelSet&, const Particle&, const Domain2D&);
	static vector2 velocity(const Coordinates&, const Particle&); //vb

	static vector2 cross(double, const vector2&);
	static double cross(const vector2&, const vector2&);
	static LevelSet merge(const std::vector<Particle>&, const Domain2D&);
	//-----------------------------------------------------
	////Size of bounding box
	//-----------------------------------------------------
	//static double AABB_extent(const Polygon&); //using the vertices, for problems where polygons are generated by vertices
	static double AABB_extent(const LevelSet&); //using the level set function
};

struct Moving_RB
{
	//Rigid body system of moving particles
	//collection of "particles" which contain their own levelset and discretised nodes
	std::vector<Particle> particles;
	Euler2D fluid;

	LevelSet combinedls;
	//Eigen::Array<vector2, Eigen::Dynamic, Eigen::Dynamic> normal;

	Moving_RB() : particles(0), fluid(), combinedls() {} //, normal(0, 0) {}
	~Moving_RB() {};

	void add_sphere(const Domain2D&, const Coordinates&, double); //center and radius
	void add_particle(const Polygon&, const Domain2D&);

	int getNBodies(); //returns number of rigid body particles

	//-----------------------------------------------------
	//Construction of AABB (and?) sorting by size
	//-----------------------------------------------------


private:
	Moving_RB(const Moving_RB& rbsystem) : particles(rbsystem.particles), fluid(rbsystem.fluid), combinedls(rbsystem.combinedls) {}

};

#endif /* PARTICLES_H_ */